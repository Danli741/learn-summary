# MVCC浅析

在并发读写数据库时，读操作可能会存在不一致的数据（脏读）。为了避免这种情况，需要实现数据库的并发访问控制，最简单的方式就是加锁访问。由于加锁会将读写操作串行化，所以不会出现不一致的状态。但是读操作会被写操作阻塞，大幅降低读性能。在Java concurrent包中，有copyonwrite系列的类，专门用于优化读远大于写的情况。而其优化的手段就是，在进行写操作时，将数据copy一份，不会影响原有数据，然后进行修改，修改完成后原子替换掉旧的数据，而读操作只会读取原有数据。通过这种方式实现写操作不会阻塞读操作，从而优化读效率。而写操作之间是要互斥的，并且每次写操作都会有一次copy，所以只适合读大于写的情况。

MVCC的原理与copyonwrite类似，全称是Multi-Version Concurrent Control，即多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。
实现原理：

---------------------------------------------------> 时间轴
&ensp;&ensp;&ensp;&ensp;|-------R(T1)-----|
&ensp;&ensp;|-----------W(T2)-----------|

如上图，假设有两个并发操作R(T1)和W(T2)，T1和T2是事务ID，T1小于T2，系统中包含数据a = 1(T1)，R和W的操作如下：

		R：read a (T1)
		W：a = 2  (T2)

R（读操作）的版本T1表示要读取数据的版本，而之后写操作才会更新版本，读操作不会。在时间轴上，R晚于W，而由于W在R开始之后提交，所以对于R是不可见的。所以，R只会读取T1版本的数据，即a = 1。
由于在update操作提交之前，不能影响已有数据的一致性，所以不会改变旧的数据，update操作会被拆分成insert + delete。需要标记删除旧的数据，insert新的数据。只有update提交之后，才会影响后续的读操作。而对于读操作，只能读到在其之前的所有的写操作，正在执行中的写操作对其是不可见的。

看一下MySQL的innodb引擎是如何实现MVCC的。innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在隔离级别是READ COMMITED(Oracle默认）和REPEATABLE READ（MySQL默认）两个隔离级别下，具体各种数据库操作的实现：
> * select：满足以下两个条件innodb会返回该行数据：
（1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
（2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。
> * insert：将新插入的行的创建版本号设置为当前系统的版本号。
> * delete：将要删除的行的删除版本号设置为当前系统的版本号。
> * update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。
其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。
由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。
	
通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。